# -*- coding: utf-8 -*-
"""
–ú–æ–¥—É–ª—å –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å Anki —á–µ—Ä–µ–∑ AnkiConnect API.
"""
import os
import requests
import base64
from typing import List, Optional, Dict, Any, Union
from core.logger import debug_log

# –ö–æ–Ω—Å—Ç–∞–Ω—Ç—ã
MODEL_NAME = "YouTube"
ANKI_CONNECT_URL = "http://localhost:8765"
DEFAULT_TIMEOUT = 5


class AnkiAPI:
    """–ö–ª–∞—Å—Å –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å Anki —á–µ—Ä–µ–∑ AnkiConnect"""
    
    def __init__(self, url: str = ANKI_CONNECT_URL):
        self.url = url
        self.model_name = MODEL_NAME
        self.session = requests.Session()
    
    def _request(self, action: str, params: Dict = None, timeout: float = DEFAULT_TIMEOUT) -> Any:
        """
        –û—Ç–ø—Ä–∞–≤–ª—è–µ—Ç –∑–∞–ø—Ä–æ—Å –∫ AnkiConnect.
        
        Args:
            action: –ù–∞–∑–≤–∞–Ω–∏–µ –¥–µ–π—Å—Ç–≤–∏—è API
            params: –ü–∞—Ä–∞–º–µ—Ç—Ä—ã –∑–∞–ø—Ä–æ—Å–∞
            timeout: –¢–∞–π–º–∞—É—Ç –≤ —Å–µ–∫—É–Ω–¥–∞—Ö
            
        Returns:
            –†–µ–∑—É–ª—å—Ç–∞—Ç –∑–∞–ø—Ä–æ—Å–∞
            
        Raises:
            Exception: –ü—Ä–∏ –æ—à–∏–±–∫–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è –∏–ª–∏ API
        """
        payload = {"action": action, "version": 6}
        if params:
            payload["params"] = params
        
        try:
            # –ò—Å–ø–æ–ª—å–∑—É–µ–º —Å–µ—Å—Å–∏—é –¥–ª—è –ø–µ—Ä–µ–∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è
            response = self.session.post(self.url, json=payload, timeout=timeout)
            result = response.json()
            
            if result.get("error"):
                raise Exception(result["error"])
            
            return result.get("result")
        except requests.exceptions.ConnectionError:
            raise Exception("ANKI_CONNECT_ERROR")
        except requests.exceptions.Timeout:
            raise Exception("ANKI_TIMEOUT_ERROR")
    
    def is_available(self) -> bool:
        """–ü—Ä–æ–≤–µ—Ä—è–µ—Ç –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å AnkiConnect"""
        try:
            self._request("version", timeout=0.5)
            return True
        except Exception:
            return False
    
    # === –ú–æ–¥–µ–ª–∏ ===
    
    def get_model_names(self) -> List[str]:
        """–ü–æ–ª—É—á–∞–µ—Ç —Å–ø–∏—Å–æ–∫ –∏–º–µ–Ω –º–æ–¥–µ–ª–µ–π"""
        return self._request("modelNames", timeout=1) or []
    
    def model_exists(self, model_name: str = None) -> bool:
        """–ü—Ä–æ–≤–µ—Ä—è–µ—Ç —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏–µ –º–æ–¥–µ–ª–∏ (—Ä–µ–≥–∏—Å—Ç—Ä–æ–Ω–µ–∑–∞–≤–∏—Å–∏–º–æ)"""
        name = (model_name or self.model_name).strip().lower()
        existing_models = [m.strip().lower() for m in self.get_model_names()]
        return name in existing_models
    
    def get_model_field_names(self, model_name: str = None) -> List[str]:
        """–ü–æ–ª—É—á–∞–µ—Ç —Å–ø–∏—Å–æ–∫ –ø–æ–ª–µ–π –º–æ–¥–µ–ª–∏"""
        name = model_name or self.model_name
        try:
            return self._request("modelFieldNames", {"modelName": name}, timeout=1) or []
        except Exception:
            return []

    def setup_model(self) -> bool:
        """
        –°–æ–∑–¥–∞–µ—Ç —Ç–∏–ø –∑–∞–ø–∏—Å–∏ 'YouTube' —Å –ø–æ–ª—è–º–∏ –∏ CSS —Å—Ç–∏–ª—è–º–∏.
        –ï—Å–ª–∏ –º–æ–¥–µ–ª—å —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç, –ø—Ä–æ–≤–µ—Ä—è–µ—Ç –Ω–∞–ª–∏—á–∏–µ –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã—Ö –ø–æ–ª–µ–π.
        
        Returns:
            True –µ—Å–ª–∏ –º–æ–¥–µ–ª—å —Å–æ–∑–¥–∞–Ω–∞ –∏–ª–∏ —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
        """
        required_fields = ["Phrase", "Translation", "Context", "Sound"]
        css = """
        .card {
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            font-size: 20px;
            text-align: center;
        }
        .phrase {
            font-size: 32px;
            font-weight: bold;
            margin-bottom: 20px;
            color: #ffffff;
        }
        .translation {
            font-size: 24px;
            margin-top: 20px;
        }
        .context {
            font-size: 16px;
            font-style: italic;
            margin-top: 15px;
            text-align: left;
            display: inline-block;
            max-width: 90%;
            background-color: #333333;
            color: #ffffff;
            padding: 12px;
            border-radius: 8px;
            border: 1px solid #444;
        }
        .sound { margin-top: 10px; }
        """
        
        card_templates = [
            {
                "name": "Card 1",
                "Front": '<div class="phrase">{{Phrase}}</div><div class="sound">{{Sound}}</div>',
                "Back": '<div class="phrase">{{Phrase}}</div><hr id="answer"><div class="translation">{{Translation}}</div><div class="context">{{Context}}<div class="watermark" style="font-size: 10px; margin-top: 10px; text-align: right;"><a href="https://LanguageSage.github.io/Anki-card-andder/" style="color: #666; text-decoration: none;">Generated by Lerne Assistant</a></div></div>'
            }
        ]

        existing_models = self.get_model_names()
        existing_models_lower = [m.lower().strip() for m in existing_models]
        target_lower = self.model_name.lower().strip()

        if target_lower in existing_models_lower:
            # –ù–∞—Ö–æ–¥–∏–º –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω–æ–µ –∏–º—è –º–æ–¥–µ–ª–∏ (–∫–æ—Ç–æ—Ä–æ–µ –≤ Anki)
            original_index = existing_models_lower.index(target_lower)
            actual_model_name = existing_models[original_index]
            self.model_name = actual_model_name # –ü—Ä–∏–Ω–∏–º–∞–µ–º –∏–º—è –∏–∑ Anki
            
            # –ï—Å–ª–∏ –º–æ–¥–µ–ª—å —Å—É—â–µ—Å—Ç–≤—É–µ—Ç, –ø—Ä–æ–≤–µ—Ä—è–µ–º –ø–æ–ª—è
            current_fields = self.get_model_field_names(actual_model_name)
            missing_fields = [f for f in required_fields if f not in current_fields]
            
            if missing_fields:
                print(f"‚ö†Ô∏è –í –º–æ–¥–µ–ª–∏ '{self.model_name}' –æ—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç –ø–æ–ª—è: {missing_fields}. –ü–æ–ø—ã—Ç–∫–∞ –¥–æ–±–∞–≤–∏—Ç—å...")
                for field in missing_fields:
                    try:
                        self._request("modelFieldAdd", {
                            "modelName": self.model_name,
                            "fieldName": field
                        })
                        print(f"‚úÖ –ü–æ–ª–µ '{field}' –¥–æ–±–∞–≤–ª–µ–Ω–æ.")
                    except Exception as e:
                        print(f"‚ùå –û—à–∏–±–∫–∞ –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –ø–æ–ª—è '{field}': {e}")
            
            # –¢–∞–∫–∂–µ –æ–±–Ω–æ–≤–ª—è–µ–º CSS –∏ —à–∞–±–ª–æ–Ω—ã –Ω–∞ –≤—Å—è–∫–∏–π —Å–ª—É—á–∞–π
            try:
                self._request("updateModelStyling", {
                    "model": {
                        "name": self.model_name,
                        "css": css
                    }
                })
                self._request("updateModelTemplates", {
                    "model": {
                        "name": self.model_name,
                        "templates": {
                            "Card 1": {
                                "Front": card_templates[0]["Front"],
                                "Back": card_templates[0]["Back"]
                            }
                        }
                    }
                })
                print(f"‚úÖ –°—Ç–∏–ª–∏ –∏ —à–∞–±–ª–æ–Ω—ã –º–æ–¥–µ–ª–∏ '{self.model_name}' –æ–±–Ω–æ–≤–ª–µ–Ω—ã.")
            except Exception as e:
                print(f"‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å –æ–±–Ω–æ–≤–∏—Ç—å —Å—Ç–∏–ª–∏/—à–∞–±–ª–æ–Ω—ã: {e}")
                
            return True
        
        print(f"üõ† –ù–∞—Å—Ç—Ä–æ–π–∫–∞ Anki: —Å–æ–∑–¥–∞–Ω–∏–µ —Ç–∏–ø–∞ –∑–∞–ø–∏—Å–∏ '{self.model_name}'...")
        
        try:
            self._request("createModel", {
                "modelName": self.model_name,
                "inOrderFields": required_fields,
                "css": css,
                "cardTemplates": card_templates
            })
            print(f"‚úÖ –¢–∏–ø –∑–∞–ø–∏—Å–∏ '{self.model_name}' —É—Å–ø–µ—à–Ω–æ —Å–æ–∑–¥–∞–Ω!")
            return True
        except Exception as e:
            print(f"‚ùå –û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –º–æ–¥–µ–ª–∏: {e}")
            return False
    
    # === –ö–æ–ª–æ–¥—ã ===
    
    def get_deck_names(self, with_counts: bool = True) -> Union[List[str], str]:
        """
        –ü–æ–ª—É—á–∞–µ—Ç —Å–ø–∏—Å–æ–∫ –∫–æ–ª–æ–¥.
        
        Args:
            with_counts: –ï—Å–ª–∏ True, –¥–æ–±–∞–≤–ª—è–µ—Ç –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∫–∞—Ä—Ç–æ—á–µ–∫
            
        Returns:
            –°–ø–∏—Å–æ–∫ –∫–æ–ª–æ–¥ –∏–ª–∏ "ANKI_CONNECT_ERROR"
        """
        try:
            deck_names = self._request("deckNames", timeout=0.5) or []
            
            if not with_counts:
                return sorted(deck_names)
            
            # –ü–æ–ª—É—á–∞–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
            stats = self._request("getDeckStats", {"decks": deck_names}, timeout=1.0) or {}
            
            deck_counts = {}
            for deck_id, stat in stats.items():
                name = stat.get("name")
                count = stat.get("total_in_deck", 0)
                if name:
                    deck_counts[name] = count
            
            # –§–æ—Ä–º–∏—Ä—É–µ–º —Å–ø–∏—Å–æ–∫ "–ò–º—è (–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ)"
            formatted = [f"{name} ({deck_counts.get(name, 0)})" for name in deck_names]
            return sorted(formatted)
            
        except Exception as e:
            if "ANKI_CONNECT_ERROR" in str(e):
                return "ANKI_CONNECT_ERROR"
            print(f"–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –∫–æ–ª–æ–¥: {e}")
            return []
    
    def create_deck(self, deck_name: str) -> bool:
        """–°–æ–∑–¥–∞–µ—Ç –Ω–æ–≤—É—é –∫–æ–ª–æ–¥—É"""
        if not deck_name or not deck_name.strip():
            return False
        
        try:
            self._request("createDeck", {"deck": deck_name.strip()}, timeout=8)
            return True
        except Exception as e:
            print(f"‚ùå –û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –∫–æ–ª–æ–¥—ã: {e}")
            return False
    
    @staticmethod
    def clean_deck_name(display_name: str) -> str:
        """
        –£–±–∏—Ä–∞–µ—Ç —Å—É—Ñ—Ñ–∏–∫—Å —Å –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ–º –∫–∞—Ä—Ç–æ—á–µ–∫.
        –ü—Ä–∏–º–µ—Ä: "Deutsch (150)" -> "Deutsch"
        """
        if not display_name:
            return ""
        
        last_open_paren = display_name.rfind(" (")
        if last_open_paren != -1 and display_name.endswith(")"):
            content = display_name[last_open_paren+2:-1]
            if content.isdigit():
                return display_name[:last_open_paren]
        return display_name
    
    # === –ó–∞–º–µ—Ç–∫–∏ ===
    
    def find_notes(self, phrase: str) -> List[int]:
        """–ò—â–µ—Ç ID –∑–∞–º–µ—Ç–æ–∫ —Å —Ç–∞–∫–æ–π –∂–µ —Ñ—Ä–∞–∑–æ–π"""
        try:
            escaped_phrase = phrase.replace('"', '\\"')
            query = f'Phrase:"{escaped_phrase}"'
            return self._request("findNotes", {"query": query}, timeout=3) or []
        except Exception as e:
            print(f"‚ö†Ô∏è –û—à–∏–±–∫–∞ –ø–æ–∏—Å–∫–∞ –∑–∞–º–µ—Ç–æ–∫: {e}")
            return []
    
    def delete_notes(self, note_ids: List[int]) -> bool:
        """–£–¥–∞–ª—è–µ—Ç –∑–∞–º–µ—Ç–∫–∏ –ø–æ –∏—Ö ID"""
        if not note_ids:
            return True
        
        try:
            self._request("deleteNotes", {"notes": note_ids})
            return True
        except Exception as e:
            print(f"‚ùå –û—à–∏–±–∫–∞ —É–¥–∞–ª–µ–Ω–∏—è –∑–∞–º–µ—Ç–æ–∫: {e}")
            return False
    
    def add_note(self, phrase: str, translation: str, context: str, 
                 deck_name: str, audio_path: str = None, allow_duplicate: bool = False) -> bool:
        """
        –î–æ–±–∞–≤–ª—è–µ—Ç –∑–∞–º–µ—Ç–∫—É –≤ Anki.
        
        Args:
            phrase: –ù–µ–º–µ—Ü–∫–∞—è —Ñ—Ä–∞–∑–∞
            translation: –ü–µ—Ä–µ–≤–æ–¥
            context: –ö–æ–Ω—Ç–µ–∫—Å—Ç
            deck_name: –ò–º—è –∫–æ–ª–æ–¥—ã
            audio_path: –ü—É—Ç—å –∫ –∞—É–¥–∏–æ—Ñ–∞–π–ª—É (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)
            allow_duplicate: –†–∞–∑—Ä–µ—à–∏—Ç—å –¥–æ–±–∞–≤–ª–µ–Ω–∏–µ –¥—É–±–ª–∏–∫–∞—Ç–æ–≤ (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é False)
            
        Returns:
            True –ø—Ä–∏ —É—Å–ø–µ—Ö–µ
        """
        clean_name = self.clean_deck_name(deck_name)
        
        def _log(msg):
            debug_log(msg, prefix="[API]")

        note = {
            "deckName": clean_name,
            "modelName": self.model_name,
            "fields": {
                "Phrase": phrase.replace('\n', '<br>'),
                "Translation": translation.replace('\n', '<br>'),
                "Context": context.replace('\n', '<br>'),
                "Sound": ""  # Explicitly include the Sound field
            },
            "options": {
                "allowDuplicate": allow_duplicate
            },
            "tags": ["youtube", "german", "local-ai"]
        }
        
        if audio_path and os.path.exists(audio_path):
            try:
                with open(audio_path, "rb") as f:
                    audio_data = base64.b64encode(f.read()).decode("utf-8")
                
                # Check for correct field name casing
                actual_fields = self.get_model_field_names()
                _log(f"üìã Actual fields in model: {actual_fields}")
                target_field = "Sound"
                if "Sound" not in actual_fields:
                    # Try to find a case-insensitive match or fallback to the first likely field
                    for gf in actual_fields:
                        if gf.lower() == "sound" or gf.lower() == "audio":
                            target_field = gf
                            _log(f"üîç Found matching field: '{target_field}'")
                            break
                
                _log(f"üîä Attaching audio to field '{target_field}'. File: {os.path.basename(audio_path)}")
                
                note["audio"] = [{
                    "data": audio_data,
                    "filename": os.path.basename(audio_path),
                    "fields": [target_field]
                }]
            except Exception as e:
                _log(f"‚ö†Ô∏è –û—à–∏–±–∫–∞ –∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏—è –∞—É–¥–∏–æ –≤ Base64: {e}")
        
        result = self._request("addNote", {"note": note})
        _log(f"üéØ Anki response: {result}")
        return True


# –ì–ª–æ–±–∞–ª—å–Ω—ã–π —ç–∫–∑–µ–º–ø–ª—è—Ä API
anki_api = AnkiAPI()
